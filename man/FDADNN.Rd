% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FDADNN.R
\name{FDADNN}
\alias{FDADNN}
\title{Functional data via Deep neural network}
\usage{
FDADNN(Data, d, Grid, N, n, L, p, s, epoch, batch, k)
}
\arguments{
\item{Data}{List of n, each element is a d dimension array.}

\item{d}{Dimension of data.}

\item{Grid}{List of d, each gives a vector of selected grid points.}

\item{N}{Vector of length d, the ith element is the number of grid points in the ith dimension, no more than 4.}

\item{n}{sample size.}

\item{L}{Vector for number of hidden layers.}

\item{p}{Vector for widths, each layer has the same width.}

\item{s}{Vector for L1 regularization of factor, from 0 to 1.}

\item{epoch}{Number of epochs.}

\item{batch}{Batch size.}

\item{k}{Number of folds for cross validation.}
}
\value{
A list of numbers, including:
\item{pse}{Prediction error of the whole data with cross-validated model.}
\item{L.opt}{Optimal number of hidden layers by \code{k}-fold cross-validation.}
\item{s.opt}{Optimal factor of L1 regularization by \code{k}-fold cross-validation.}
\item{p.opt}{Optimal number of neurons in each layer by \code{k}-fold cross-validation.}
}
\description{
This function trains the deep neural network for functional inputs.
}
\examples{
## Two dimension functional data
library(pracma)
library(MASS)
d=2; N=c(3, 5); n=50 
## Generate data
Grid=list()
Grid[[1]]=seq(1/N[1],1.00,length.out = N[1])
Grid[[2]]=seq(1/N[2],1.00,length.out = N[2])
x_data.1=as.vector(replicate(N[2], Grid[[1]]))
x_data.2=as.vector(t(replicate(N[1], Grid[[2]])))
x_train=cbind(x_data.1, x_data.2)
## True function
y_train.true=(-8)*1/(1+exp(cot(x_data.1^2)*cos(2*pi*x_data.2)))
## Covariance structure
cov=array(NA, c(N[1]*N[2], N[1]*N[2], 2))
for(i in 1:(N[1]*N[2])){
 for(j in 1:(N[1]*N[2])){
   cov[i,j,1]=cos(2*pi*(x_data.1[i] - x_data.1[j]))
   cov[i,j,2]=cos(2*pi*(x_data.2[i] - x_data.2[j]))
 }
}
Data=array(NA, c(n, N[1], N[2]))
for(i in 1:n){
 error=mvrnorm(1, rep(0, N[1]*N[2]), (cov[,,1]+cov[,,2]))+rnorm(1, 0, 1)
 Data[i,,]=matrix(error, N[1], N[2])+matrix(y_train.true, N[1], N[2])
}
FDADNN(Data, d, Grid, N, n, 3, 100, 0.01, 100, 32, 5)
}
